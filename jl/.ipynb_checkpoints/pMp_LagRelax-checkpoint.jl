{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "imperial-campus",
   "metadata": {},
   "outputs": [
    {
     "ename": "LoadError",
     "evalue": "MethodError: Cannot `convert` an object of type SubString{String} to an object of type Float64\nClosest candidates are:\n  convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n  convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n  convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250\n  ...",
     "output_type": "error",
     "traceback": [
      "MethodError: Cannot `convert` an object of type SubString{String} to an object of type Float64\nClosest candidates are:\n  convert(::Type{T}, !Matched::T) where T<:Number at number.jl:6\n  convert(::Type{T}, !Matched::Number) where T<:Number at number.jl:7\n  convert(::Type{T}, !Matched::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250\n  ...",
      "",
      "Stacktrace:",
      " [1] setindex!(::Array{Float64,2}, ::SubString{String}, ::Int64) at .\\array.jl:847",
      " [2] _unsafe_copyto!(::Array{Float64,2}, ::Int64, ::Array{Any,2}, ::Int64, ::Int64) at .\\array.jl:257",
      " [3] unsafe_copyto! at .\\array.jl:311 [inlined]",
      " [4] _copyto_impl! at .\\array.jl:335 [inlined]",
      " [5] copyto! at .\\array.jl:321 [inlined]",
      " [6] copyto! at .\\array.jl:347 [inlined]",
      " [7] copyto_axcheck! at .\\abstractarray.jl:946 [inlined]",
      " [8] Array{Float64,2}(::Array{Any,2}) at .\\array.jl:562",
      " [9] convert(::Type{Array{Float64,2}}, ::Array{Any,2}) at .\\array.jl:554",
      " [10] top-level scope at In[11]:12",
      " [11] include_string(::Function, ::Module, ::String, ::String) at .\\loading.jl:1091"
     ]
    }
   ],
   "source": [
    "using JuMP, Gurobi, PyPlot, DelimitedFiles\n",
    "using Printf\n",
    "# Solving the p-median problem by Lagrangian Relaxation\n",
    "p = 3\n",
    "\n",
    "# Reading demand data\n",
    "d, header = readdlm(\"demand.csv\", ',',header=true)\n",
    "\n",
    "# Reading transportation cost data\n",
    "data = readdlm(\"cost.csv\", ',')\n",
    "c = data[1:end, 1:end]\n",
    "c = convert(Array{Float64,2}, c)\n",
    "# the length of 'd' and the number of columns in 'c' must match\n",
    "@assert length(d) == size(c,2)\n",
    "\n",
    "locations = 1:size(c,1) # the set, I\n",
    "customers = 1:length(d) # the set, J\n",
    "\n",
    "\n",
    "# function optimal(p)\n",
    "#   m = Model(solver=GurobiSolver())\n",
    "\n",
    "#   @variable(m, x[i in locations, j in customers] >= 0)\n",
    "#   @variable(m, y[i in locations], Bin)\n",
    "\n",
    "#   @objective(m, Min, sum( d[j]*c[i,j]*x[i,j]\n",
    "#                      for i in locations, j in customers) )\n",
    "\n",
    "#   for j in customers\n",
    "#     @constraint(m, sum( x[i,j] for i in locations) == 1)\n",
    "#   end\n",
    "\n",
    "#   @constraint(m, sum( y[i] for i in locations) == p)\n",
    "\n",
    "#   for i in locations\n",
    "#     for j in customers\n",
    "#       @constraint(m, x[i,j] <= y[i] )\n",
    "#     end\n",
    "#   end\n",
    "\n",
    "#   solve(m)\n",
    "\n",
    "#   Z_opt = getobjectivevalue(m)\n",
    "#   x_opt = getvalue(x)\n",
    "#   y_opt = getvalue(y)\n",
    "\n",
    "#   return Z_opt, x_opt, y_opt\n",
    "# end\n",
    "\n",
    "\n",
    "\n",
    "function lower_bound(lambda, p)\n",
    "  # Step 1: Computing v\n",
    "  v = Array{Float64}(size(locations))\n",
    "  for i in locations\n",
    "    v[i] = 0\n",
    "    for j in customers\n",
    "      v[i] = v[i] + min(0, d[j]*c[i,j] - lambda[j] )\n",
    "    end\n",
    "  end\n",
    "\n",
    "  # Step 2: Sorting v from the most negative to zero\n",
    "  idx = sortperm(v)\n",
    "\n",
    "  # Step 3: Determine y\n",
    "  y = zeros(Int, size(locations))\n",
    "  y[idx[1:p]] = 1\n",
    "\n",
    "  # Step 4: Determine x\n",
    "  x = zeros(Int, length(locations), length(customers))\n",
    "  for i in locations\n",
    "    for j in customers\n",
    "      if y[i]==1 && d[j]*c[i,j]-lambda[j]<0\n",
    "        x[i,j] = 1\n",
    "      end\n",
    "    end\n",
    "  end\n",
    "\n",
    "  # Computing the Z_D(lambda^k)\n",
    "  Z_D = 0.0\n",
    "  for j in customers\n",
    "    Z_D = Z_D + lambda[j]\n",
    "    for i in locations\n",
    "      Z_D = Z_D + d[j]*c[i,j]*x[i,j] - lambda[j]*x[i,j]\n",
    "    end\n",
    "  end\n",
    "\n",
    "  return Z_D, x, y\n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "function upper_bound(y)\n",
    "  # Computing x, given y\n",
    "  x = zeros(Int, length(locations), length(customers))\n",
    "  for j in customers\n",
    "    idx = indmin( c[:,j] + (1-y)*maximum(c) )\n",
    "    x[idx,j] = 1\n",
    "  end\n",
    "\n",
    "  # Computing Z\n",
    "  Z = 0.0\n",
    "  for i in locations\n",
    "    for j in customers\n",
    "      Z = Z + d[j]*c[i,j]*x[i,j]\n",
    "    end\n",
    "  end\n",
    "  return Z, x\n",
    "end\n",
    "\n",
    "\n",
    "# The maximum number of iterations allowed\n",
    "MAX_ITER = 10000\n",
    "\n",
    "# To track the upper and lower bounds\n",
    "UB = Array{Float64}(0)\n",
    "LB = Array{Float64}(0)\n",
    "\n",
    "# The best-known upper and lower bounds\n",
    "Z_UB = Inf\n",
    "Z_LB = -Inf\n",
    "\n",
    "# The best-known feasible solutions\n",
    "x_best = zeros(length(locations), length(customers))\n",
    "y_best = zeros(length(locations))\n",
    "\n",
    "# Initial multiplier\n",
    "lambda = zeros(size(customers))\n",
    "\n",
    "# Finding the exact optimal solution\n",
    "Z_opt, x_opt, y_opt = optimal(p)\n",
    "\n",
    "for k=1:MAX_ITER\n",
    "  # Obtaining the lower and upper bounds\n",
    "  Z_D, x_D, y = lower_bound(lambda, p)\n",
    "  Z, x = upper_bound(y)\n",
    "\n",
    "  # Updating the upper bound\n",
    "  if Z < Z_UB\n",
    "    Z_UB = Z\n",
    "    x_best = x\n",
    "    y_best = y\n",
    "  end\n",
    "\n",
    "  # Updating the lower bound\n",
    "  if Z_D > Z_LB\n",
    "    Z_LB = Z_D\n",
    "  end\n",
    "\n",
    "  # Adding the bounds from the current iteration to the record\n",
    "  push!(UB, Z)\n",
    "  push!(LB, Z_D)\n",
    "\n",
    "  # Determining the step size and updating the multiplier\n",
    "  theta = 1.0\n",
    "  residual = 1 - transpose(sum(x_D, 1))\n",
    "  t = theta * (Z_UB - Z_D) / sum(residual.^2)\n",
    "  lambda = lambda + t * residual\n",
    "\n",
    "  # Computing the optimality gap\n",
    "  opt_gap = (Z_UB-Z_LB) / Z_UB\n",
    "  if opt_gap < 0.000001\n",
    "    break\n",
    "  end\n",
    "end\n",
    "\n",
    "\n",
    "\n",
    "iter = 1:length(LB)\n",
    "fig = figure()\n",
    "\n",
    "# Plotting two datasets\n",
    "plot(iter, LB, color=\"red\", linewidth=2.0, linestyle=\"-\",\n",
    "   marker=\"o\", label=\"Lower Bound\")\n",
    "plot(iter, UB, color=\"blue\", linewidth=2.0, linestyle=\"-.\",\n",
    "   marker=\"D\", label=\"Upper Bound\")\n",
    "\n",
    "# Labeling axes\n",
    "xlabel(L\"iteration clock $k$\", fontsize=\"xx-large\")\n",
    "ylabel(\"Bounds\", fontsize=\"xx-large\")\n",
    "\n",
    "# Putting the legend and determining the location\n",
    "legend(loc=\"lower right\", fontsize=\"x-large\")\n",
    "\n",
    "# Add grid lines\n",
    "grid(color=\"#DDDDDD\", linestyle=\"-\", linewidth=1.0)\n",
    "tick_params(axis=\"both\", which=\"major\", labelsize=\"x-large\")\n",
    "\n",
    "# Title\n",
    "title(\"Lower and Upper Bounds\")\n",
    "savefig(\"iterations.png\")\n",
    "savefig(\"iterations.pdf\")\n",
    "close(fig)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "varied-guidance",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "moral-funds",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Julia 1.5.3",
   "language": "julia",
   "name": "julia-1.5"
  },
  "language_info": {
   "file_extension": ".jl",
   "mimetype": "application/julia",
   "name": "julia",
   "version": "1.5.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
